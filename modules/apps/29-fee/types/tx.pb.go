// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ibc/applications/fee/v1/tx.proto

package types

import (
	context "context"
	fmt "fmt"
	types "github.com/cosmos/ibc-go/v3/modules/core/04-channel/types"
	_ "github.com/gogo/protobuf/gogoproto"
	grpc1 "github.com/gogo/protobuf/grpc"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgRegisterCounterpartyAddress defines the request type for the RegisterCounterpartyAddress rpc
type MsgRegisterCounterpartyAddress struct {
	// the relayer address
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// the counterparty relayer address
	CounterpartyAddress string `protobuf:"bytes,2,opt,name=counterparty_address,json=counterpartyAddress,proto3" json:"counterparty_address,omitempty" yaml:"counterparty_address"`
	// unique port identifier
	PortId string `protobuf:"bytes,3,opt,name=port_id,json=portId,proto3" json:"port_id,omitempty" yaml:"port_id"`
	// unique channel identifier
	ChannelId string `protobuf:"bytes,4,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty" yaml:"channel_id"`
}

func (m *MsgRegisterCounterpartyAddress) Reset()         { *m = MsgRegisterCounterpartyAddress{} }
func (m *MsgRegisterCounterpartyAddress) String() string { return proto.CompactTextString(m) }
func (*MsgRegisterCounterpartyAddress) ProtoMessage()    {}
func (*MsgRegisterCounterpartyAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_05c93128649f1b96, []int{0}
}
func (m *MsgRegisterCounterpartyAddress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRegisterCounterpartyAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRegisterCounterpartyAddress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRegisterCounterpartyAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRegisterCounterpartyAddress.Merge(m, src)
}
func (m *MsgRegisterCounterpartyAddress) XXX_Size() int {
	return m.Size()
}
func (m *MsgRegisterCounterpartyAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRegisterCounterpartyAddress.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRegisterCounterpartyAddress proto.InternalMessageInfo

// MsgRegisterCounterpartyAddressResponse defines the response type for the RegisterCounterpartyAddress rpc
type MsgRegisterCounterpartyAddressResponse struct {
}

func (m *MsgRegisterCounterpartyAddressResponse) Reset() {
	*m = MsgRegisterCounterpartyAddressResponse{}
}
func (m *MsgRegisterCounterpartyAddressResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRegisterCounterpartyAddressResponse) ProtoMessage()    {}
func (*MsgRegisterCounterpartyAddressResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_05c93128649f1b96, []int{1}
}
func (m *MsgRegisterCounterpartyAddressResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRegisterCounterpartyAddressResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRegisterCounterpartyAddressResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRegisterCounterpartyAddressResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRegisterCounterpartyAddressResponse.Merge(m, src)
}
func (m *MsgRegisterCounterpartyAddressResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRegisterCounterpartyAddressResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRegisterCounterpartyAddressResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRegisterCounterpartyAddressResponse proto.InternalMessageInfo

// MsgPayPacketFee defines the request type for the PayPacketFee rpc
// This Msg can be used to pay for a packet at the next sequence send & should be combined with the Msg that will be
// paid for
type MsgPayPacketFee struct {
	// fee encapsulates the recv, ack and timeout fees associated with an IBC packet
	Fee Fee `protobuf:"bytes,1,opt,name=fee,proto3" json:"fee"`
	// the source port unique identifier
	SourcePortId string `protobuf:"bytes,2,opt,name=source_port_id,json=sourcePortId,proto3" json:"source_port_id,omitempty" yaml:"source_port_id"`
	// the source channel unique identifer
	SourceChannelId string `protobuf:"bytes,3,opt,name=source_channel_id,json=sourceChannelId,proto3" json:"source_channel_id,omitempty" yaml:"source_channel_id"`
	// account address to refund fee if necessary
	Signer string `protobuf:"bytes,4,opt,name=signer,proto3" json:"signer,omitempty"`
	// optional list of relayers permitted to the receive packet fees
	Relayers []string `protobuf:"bytes,5,rep,name=relayers,proto3" json:"relayers,omitempty"`
}

func (m *MsgPayPacketFee) Reset()         { *m = MsgPayPacketFee{} }
func (m *MsgPayPacketFee) String() string { return proto.CompactTextString(m) }
func (*MsgPayPacketFee) ProtoMessage()    {}
func (*MsgPayPacketFee) Descriptor() ([]byte, []int) {
	return fileDescriptor_05c93128649f1b96, []int{2}
}
func (m *MsgPayPacketFee) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPayPacketFee) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPayPacketFee.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPayPacketFee) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPayPacketFee.Merge(m, src)
}
func (m *MsgPayPacketFee) XXX_Size() int {
	return m.Size()
}
func (m *MsgPayPacketFee) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPayPacketFee.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPayPacketFee proto.InternalMessageInfo

// MsgPayPacketFeeResponse defines the response type for the PayPacketFee rpc
type MsgPayPacketFeeResponse struct {
}

func (m *MsgPayPacketFeeResponse) Reset()         { *m = MsgPayPacketFeeResponse{} }
func (m *MsgPayPacketFeeResponse) String() string { return proto.CompactTextString(m) }
func (*MsgPayPacketFeeResponse) ProtoMessage()    {}
func (*MsgPayPacketFeeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_05c93128649f1b96, []int{3}
}
func (m *MsgPayPacketFeeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPayPacketFeeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPayPacketFeeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPayPacketFeeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPayPacketFeeResponse.Merge(m, src)
}
func (m *MsgPayPacketFeeResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgPayPacketFeeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPayPacketFeeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPayPacketFeeResponse proto.InternalMessageInfo

// MsgPayPacketFeeAsync defines the request type for the PayPacketFeeAsync rpc
// This Msg can be used to pay for a packet at a specified sequence (instead of the next sequence send)
type MsgPayPacketFeeAsync struct {
	// unique packet identifier comprised of the channel ID, port ID and sequence
	PacketId types.PacketId `protobuf:"bytes,1,opt,name=packet_id,json=packetId,proto3" json:"packet_id" yaml:"packet_id"`
	// the packet fee associated with a particular IBC packet
	PacketFee PacketFee `protobuf:"bytes,2,opt,name=packet_fee,json=packetFee,proto3" json:"packet_fee" yaml:"packet_fee"`
}

func (m *MsgPayPacketFeeAsync) Reset()         { *m = MsgPayPacketFeeAsync{} }
func (m *MsgPayPacketFeeAsync) String() string { return proto.CompactTextString(m) }
func (*MsgPayPacketFeeAsync) ProtoMessage()    {}
func (*MsgPayPacketFeeAsync) Descriptor() ([]byte, []int) {
	return fileDescriptor_05c93128649f1b96, []int{4}
}
func (m *MsgPayPacketFeeAsync) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPayPacketFeeAsync) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPayPacketFeeAsync.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPayPacketFeeAsync) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPayPacketFeeAsync.Merge(m, src)
}
func (m *MsgPayPacketFeeAsync) XXX_Size() int {
	return m.Size()
}
func (m *MsgPayPacketFeeAsync) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPayPacketFeeAsync.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPayPacketFeeAsync proto.InternalMessageInfo

// MsgPayPacketFeeAsyncResponse defines the response type for the PayPacketFeeAsync rpc
type MsgPayPacketFeeAsyncResponse struct {
}

func (m *MsgPayPacketFeeAsyncResponse) Reset()         { *m = MsgPayPacketFeeAsyncResponse{} }
func (m *MsgPayPacketFeeAsyncResponse) String() string { return proto.CompactTextString(m) }
func (*MsgPayPacketFeeAsyncResponse) ProtoMessage()    {}
func (*MsgPayPacketFeeAsyncResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_05c93128649f1b96, []int{5}
}
func (m *MsgPayPacketFeeAsyncResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPayPacketFeeAsyncResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPayPacketFeeAsyncResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPayPacketFeeAsyncResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPayPacketFeeAsyncResponse.Merge(m, src)
}
func (m *MsgPayPacketFeeAsyncResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgPayPacketFeeAsyncResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPayPacketFeeAsyncResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPayPacketFeeAsyncResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*MsgRegisterCounterpartyAddress)(nil), "ibc.applications.fee.v1.MsgRegisterCounterpartyAddress")
	proto.RegisterType((*MsgRegisterCounterpartyAddressResponse)(nil), "ibc.applications.fee.v1.MsgRegisterCounterpartyAddressResponse")
	proto.RegisterType((*MsgPayPacketFee)(nil), "ibc.applications.fee.v1.MsgPayPacketFee")
	proto.RegisterType((*MsgPayPacketFeeResponse)(nil), "ibc.applications.fee.v1.MsgPayPacketFeeResponse")
	proto.RegisterType((*MsgPayPacketFeeAsync)(nil), "ibc.applications.fee.v1.MsgPayPacketFeeAsync")
	proto.RegisterType((*MsgPayPacketFeeAsyncResponse)(nil), "ibc.applications.fee.v1.MsgPayPacketFeeAsyncResponse")
}

func init() { proto.RegisterFile("ibc/applications/fee/v1/tx.proto", fileDescriptor_05c93128649f1b96) }

var fileDescriptor_05c93128649f1b96 = []byte{
	// 650 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x94, 0xbf, 0x4f, 0xdb, 0x40,
	0x14, 0xc7, 0x63, 0x42, 0x81, 0x5c, 0x11, 0x34, 0x57, 0x28, 0x21, 0x50, 0x9b, 0x7a, 0xa8, 0x22,
	0x55, 0xd8, 0xe5, 0x97, 0xaa, 0xb2, 0x20, 0x82, 0x84, 0xca, 0x80, 0x8a, 0x4e, 0x9d, 0xaa, 0x4a,
	0xc8, 0x39, 0xbf, 0x18, 0xb7, 0x89, 0xcf, 0xf2, 0x39, 0x51, 0xfd, 0x0f, 0x54, 0x1d, 0xd9, 0xba,
	0xf2, 0xe7, 0x30, 0x32, 0x74, 0xe8, 0x64, 0x55, 0xb0, 0x74, 0xf6, 0xda, 0xa5, 0x3a, 0x9f, 0x1d,
	0x39, 0x94, 0x44, 0xb4, 0xdb, 0xdd, 0xbd, 0xcf, 0xfb, 0xde, 0x7b, 0x5f, 0x3f, 0x1f, 0x5a, 0x73,
	0x5b, 0xd4, 0xb4, 0x7c, 0xbf, 0xe3, 0x52, 0x2b, 0x74, 0x99, 0xc7, 0xcd, 0x36, 0x80, 0xd9, 0xdf,
	0x30, 0xc3, 0xcf, 0x86, 0x1f, 0xb0, 0x90, 0xe1, 0x25, 0xb7, 0x45, 0x8d, 0x22, 0x61, 0xb4, 0x01,
	0x8c, 0xfe, 0x46, 0x7d, 0xc1, 0x61, 0x0e, 0x4b, 0x19, 0x53, 0xac, 0x24, 0x5e, 0x7f, 0x36, 0x4a,
	0x50, 0x64, 0x15, 0x10, 0xca, 0x02, 0x30, 0xe9, 0x99, 0xe5, 0x79, 0xd0, 0x11, 0xe1, 0x6c, 0x29,
	0x11, 0xfd, 0xb7, 0x82, 0xd4, 0x63, 0xee, 0x10, 0x70, 0x5c, 0x1e, 0x42, 0x70, 0xc0, 0x7a, 0x5e,
	0x08, 0x81, 0x6f, 0x05, 0x61, 0xb4, 0x6f, 0xdb, 0x01, 0x70, 0x8e, 0x6b, 0x68, 0xda, 0x92, 0xcb,
	0x9a, 0xb2, 0xa6, 0x34, 0x2a, 0x24, 0xdf, 0x62, 0x82, 0x16, 0x68, 0x21, 0xe1, 0x34, 0xc7, 0x26,
	0x04, 0xd6, 0xd4, 0x92, 0x58, 0x5b, 0x89, 0xac, 0x6e, 0x67, 0x57, 0xbf, 0x8b, 0xd2, 0xc9, 0x63,
	0x7a, 0xc7, 0x6d, 0x2f, 0xd0, 0xb4, 0xcf, 0x82, 0xf0, 0xd4, 0xb5, 0x6b, 0xe5, 0x54, 0x06, 0x27,
	0xb1, 0x36, 0x27, 0x65, 0xb2, 0x80, 0x4e, 0xa6, 0xc4, 0xea, 0xc8, 0xc6, 0xdb, 0x08, 0x65, 0xed,
	0x08, 0x7e, 0x32, 0xe5, 0x17, 0x93, 0x58, 0xab, 0x66, 0xd7, 0x0e, 0x62, 0x3a, 0xa9, 0x64, 0x9b,
	0x23, 0x7b, 0x77, 0xe6, 0xeb, 0x85, 0x56, 0xfa, 0x75, 0xa1, 0x95, 0xf4, 0x06, 0x7a, 0x3e, 0xbe,
	0x79, 0x02, 0xdc, 0x67, 0x1e, 0x07, 0xfd, 0x7c, 0x02, 0xcd, 0x1f, 0x73, 0xe7, 0xc4, 0x8a, 0x4e,
	0x2c, 0xfa, 0x09, 0xc2, 0x43, 0x00, 0xbc, 0x8d, 0xca, 0x6d, 0x80, 0xd4, 0x94, 0x87, 0x9b, 0xab,
	0xc6, 0x88, 0xcf, 0x67, 0x1c, 0x02, 0x34, 0x27, 0x2f, 0x63, 0xad, 0x44, 0x04, 0x8e, 0xf7, 0xd0,
	0x1c, 0x67, 0xbd, 0x80, 0xc2, 0x69, 0xde, 0xa7, 0xb4, 0x6b, 0x39, 0x89, 0xb5, 0x45, 0x59, 0xf7,
	0x70, 0x5c, 0x27, 0xb3, 0xf2, 0xe0, 0x44, 0x36, 0xfd, 0x06, 0x55, 0x33, 0xa0, 0xd0, 0xbb, 0xf4,
	0x6a, 0x35, 0x89, 0xb5, 0xda, 0x90, 0x46, 0xd1, 0x82, 0x79, 0x79, 0x76, 0x90, 0x1b, 0x81, 0x9f,
	0xa0, 0x29, 0xee, 0x3a, 0x1e, 0x04, 0xd2, 0x3a, 0x92, 0xed, 0x70, 0x1d, 0xcd, 0x04, 0xd0, 0xb1,
	0x22, 0x08, 0x78, 0xed, 0xc1, 0x5a, 0xb9, 0x51, 0x21, 0x83, 0x7d, 0xc1, 0xbc, 0x65, 0xb4, 0x74,
	0xcb, 0x91, 0x81, 0x5b, 0xdf, 0x15, 0xb4, 0x70, 0x2b, 0xb6, 0xcf, 0x23, 0x8f, 0xe2, 0x77, 0xa8,
	0xe2, 0xa7, 0x27, 0xa2, 0x66, 0x69, 0xdc, 0xd3, 0xd4, 0x38, 0x31, 0xa5, 0x46, 0x3e, 0x9a, 0xfd,
	0x0d, 0x43, 0xe6, 0x1d, 0xd9, 0xcd, 0x9a, 0x70, 0x2e, 0x89, 0xb5, 0x47, 0xd9, 0x08, 0xe4, 0xd9,
	0x3a, 0x99, 0xf1, 0x33, 0x06, 0x7f, 0x40, 0x28, 0x3b, 0x17, 0xdf, 0x63, 0x22, 0x95, 0xd5, 0x47,
	0x7e, 0x8f, 0x41, 0x49, 0xcd, 0xe5, 0x4c, 0xbb, 0x3a, 0xa4, 0xdd, 0x06, 0xd0, 0x49, 0x56, 0xe6,
	0x21, 0x40, 0xa1, 0x63, 0x15, 0xad, 0xde, 0xd5, 0x55, 0xde, 0xf6, 0xe6, 0x97, 0x32, 0x2a, 0x1f,
	0x73, 0x07, 0x7f, 0x53, 0xd0, 0xca, 0xb8, 0x3f, 0xea, 0xd5, 0xc8, 0xda, 0xc6, 0x4f, 0x63, 0x7d,
	0xef, 0x3f, 0x13, 0xf3, 0x0a, 0xf1, 0x47, 0x34, 0x3b, 0x34, 0xc2, 0x8d, 0x71, 0x82, 0x45, 0xb2,
	0xfe, 0xf2, 0xbe, 0xe4, 0xe0, 0xae, 0x08, 0x55, 0xff, 0x1e, 0x80, 0xf5, 0xfb, 0xca, 0xa4, 0x78,
	0x7d, 0xe7, 0x9f, 0xf0, 0xfc, 0xea, 0xe6, 0xdb, 0xcb, 0x6b, 0x55, 0xb9, 0xba, 0x56, 0x95, 0x9f,
	0xd7, 0xaa, 0x72, 0x7e, 0xa3, 0x96, 0xae, 0x6e, 0xd4, 0xd2, 0x8f, 0x1b, 0xb5, 0xf4, 0x7e, 0xc7,
	0x71, 0xc3, 0xb3, 0x5e, 0xcb, 0xa0, 0xac, 0x6b, 0x52, 0xc6, 0xbb, 0x8c, 0x9b, 0x6e, 0x8b, 0xae,
	0x3b, 0xcc, 0xec, 0x6f, 0x99, 0x5d, 0x66, 0xf7, 0x3a, 0xc0, 0xc5, 0xab, 0xca, 0xcd, 0xcd, 0xd7,
	0xeb, 0xe2, 0x41, 0x0d, 0x23, 0x1f, 0x78, 0x6b, 0x2a, 0x7d, 0x2d, 0xb7, 0xfe, 0x04, 0x00, 0x00,
	0xff, 0xff, 0xcb, 0x30, 0xa1, 0x30, 0xc6, 0x05, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// RegisterCounterpartyAddress defines a rpc handler method for MsgRegisterCounterpartyAddress
	// RegisterCounterpartyAddress is called by the relayer on each channelEnd and allows them to specify their
	// counterparty address before relaying. This ensures they will be properly compensated for forward relaying since
	// destination chain must send back relayer's source address (counterparty address) in acknowledgement. This function
	// may be called more than once by a relayer, in which case, latest counterparty address is always used.
	RegisterCounterpartyAddress(ctx context.Context, in *MsgRegisterCounterpartyAddress, opts ...grpc.CallOption) (*MsgRegisterCounterpartyAddressResponse, error)
	// PayPacketFee defines a rpc handler method for MsgPayPacketFee
	// PayPacketFee is an open callback that may be called by any module/user that wishes to escrow funds in order to
	// incentivize the relaying of the packet at the next sequence
	// NOTE: This method is intended to be used within a multi msg transaction, where the subsequent msg that follows
	// initiates the lifecycle of the incentivized packet
	PayPacketFee(ctx context.Context, in *MsgPayPacketFee, opts ...grpc.CallOption) (*MsgPayPacketFeeResponse, error)
	// PayPacketFeeAsync defines a rpc handler method for MsgPayPacketFeeAsync
	// PayPacketFeeAsync is an open callback that may be called by any module/user that wishes to escrow funds in order to
	// incentivize the relaying of a known packet (i.e. at a particular sequence)
	PayPacketFeeAsync(ctx context.Context, in *MsgPayPacketFeeAsync, opts ...grpc.CallOption) (*MsgPayPacketFeeAsyncResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) RegisterCounterpartyAddress(ctx context.Context, in *MsgRegisterCounterpartyAddress, opts ...grpc.CallOption) (*MsgRegisterCounterpartyAddressResponse, error) {
	out := new(MsgRegisterCounterpartyAddressResponse)
	err := c.cc.Invoke(ctx, "/ibc.applications.fee.v1.Msg/RegisterCounterpartyAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) PayPacketFee(ctx context.Context, in *MsgPayPacketFee, opts ...grpc.CallOption) (*MsgPayPacketFeeResponse, error) {
	out := new(MsgPayPacketFeeResponse)
	err := c.cc.Invoke(ctx, "/ibc.applications.fee.v1.Msg/PayPacketFee", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) PayPacketFeeAsync(ctx context.Context, in *MsgPayPacketFeeAsync, opts ...grpc.CallOption) (*MsgPayPacketFeeAsyncResponse, error) {
	out := new(MsgPayPacketFeeAsyncResponse)
	err := c.cc.Invoke(ctx, "/ibc.applications.fee.v1.Msg/PayPacketFeeAsync", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// RegisterCounterpartyAddress defines a rpc handler method for MsgRegisterCounterpartyAddress
	// RegisterCounterpartyAddress is called by the relayer on each channelEnd and allows them to specify their
	// counterparty address before relaying. This ensures they will be properly compensated for forward relaying since
	// destination chain must send back relayer's source address (counterparty address) in acknowledgement. This function
	// may be called more than once by a relayer, in which case, latest counterparty address is always used.
	RegisterCounterpartyAddress(context.Context, *MsgRegisterCounterpartyAddress) (*MsgRegisterCounterpartyAddressResponse, error)
	// PayPacketFee defines a rpc handler method for MsgPayPacketFee
	// PayPacketFee is an open callback that may be called by any module/user that wishes to escrow funds in order to
	// incentivize the relaying of the packet at the next sequence
	// NOTE: This method is intended to be used within a multi msg transaction, where the subsequent msg that follows
	// initiates the lifecycle of the incentivized packet
	PayPacketFee(context.Context, *MsgPayPacketFee) (*MsgPayPacketFeeResponse, error)
	// PayPacketFeeAsync defines a rpc handler method for MsgPayPacketFeeAsync
	// PayPacketFeeAsync is an open callback that may be called by any module/user that wishes to escrow funds in order to
	// incentivize the relaying of a known packet (i.e. at a particular sequence)
	PayPacketFeeAsync(context.Context, *MsgPayPacketFeeAsync) (*MsgPayPacketFeeAsyncResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) RegisterCounterpartyAddress(ctx context.Context, req *MsgRegisterCounterpartyAddress) (*MsgRegisterCounterpartyAddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterCounterpartyAddress not implemented")
}
func (*UnimplementedMsgServer) PayPacketFee(ctx context.Context, req *MsgPayPacketFee) (*MsgPayPacketFeeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PayPacketFee not implemented")
}
func (*UnimplementedMsgServer) PayPacketFeeAsync(ctx context.Context, req *MsgPayPacketFeeAsync) (*MsgPayPacketFeeAsyncResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PayPacketFeeAsync not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_RegisterCounterpartyAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRegisterCounterpartyAddress)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RegisterCounterpartyAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ibc.applications.fee.v1.Msg/RegisterCounterpartyAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RegisterCounterpartyAddress(ctx, req.(*MsgRegisterCounterpartyAddress))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_PayPacketFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgPayPacketFee)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).PayPacketFee(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ibc.applications.fee.v1.Msg/PayPacketFee",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).PayPacketFee(ctx, req.(*MsgPayPacketFee))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_PayPacketFeeAsync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgPayPacketFeeAsync)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).PayPacketFeeAsync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ibc.applications.fee.v1.Msg/PayPacketFeeAsync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).PayPacketFeeAsync(ctx, req.(*MsgPayPacketFeeAsync))
	}
	return interceptor(ctx, in, info, handler)
}

var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ibc.applications.fee.v1.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterCounterpartyAddress",
			Handler:    _Msg_RegisterCounterpartyAddress_Handler,
		},
		{
			MethodName: "PayPacketFee",
			Handler:    _Msg_PayPacketFee_Handler,
		},
		{
			MethodName: "PayPacketFeeAsync",
			Handler:    _Msg_PayPacketFeeAsync_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ibc/applications/fee/v1/tx.proto",
}

func (m *MsgRegisterCounterpartyAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRegisterCounterpartyAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRegisterCounterpartyAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChannelId) > 0 {
		i -= len(m.ChannelId)
		copy(dAtA[i:], m.ChannelId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ChannelId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PortId) > 0 {
		i -= len(m.PortId)
		copy(dAtA[i:], m.PortId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PortId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CounterpartyAddress) > 0 {
		i -= len(m.CounterpartyAddress)
		copy(dAtA[i:], m.CounterpartyAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CounterpartyAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRegisterCounterpartyAddressResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRegisterCounterpartyAddressResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRegisterCounterpartyAddressResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgPayPacketFee) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPayPacketFee) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPayPacketFee) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Relayers) > 0 {
		for iNdEx := len(m.Relayers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Relayers[iNdEx])
			copy(dAtA[i:], m.Relayers[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.Relayers[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Signer) > 0 {
		i -= len(m.Signer)
		copy(dAtA[i:], m.Signer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Signer)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SourceChannelId) > 0 {
		i -= len(m.SourceChannelId)
		copy(dAtA[i:], m.SourceChannelId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SourceChannelId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SourcePortId) > 0 {
		i -= len(m.SourcePortId)
		copy(dAtA[i:], m.SourcePortId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SourcePortId)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Fee.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgPayPacketFeeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPayPacketFeeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPayPacketFeeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgPayPacketFeeAsync) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPayPacketFeeAsync) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPayPacketFeeAsync) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.PacketFee.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.PacketId.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgPayPacketFeeAsyncResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPayPacketFeeAsyncResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPayPacketFeeAsyncResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgRegisterCounterpartyAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.CounterpartyAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.PortId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ChannelId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgRegisterCounterpartyAddressResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgPayPacketFee) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Fee.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.SourcePortId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SourceChannelId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Signer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Relayers) > 0 {
		for _, s := range m.Relayers {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgPayPacketFeeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgPayPacketFeeAsync) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.PacketId.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.PacketFee.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgPayPacketFeeAsyncResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgRegisterCounterpartyAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRegisterCounterpartyAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRegisterCounterpartyAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CounterpartyAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CounterpartyAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRegisterCounterpartyAddressResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRegisterCounterpartyAddressResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRegisterCounterpartyAddressResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPayPacketFee) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPayPacketFee: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPayPacketFee: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourcePortId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourcePortId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceChannelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceChannelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relayers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Relayers = append(m.Relayers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPayPacketFeeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPayPacketFeeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPayPacketFeeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPayPacketFeeAsync) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPayPacketFeeAsync: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPayPacketFeeAsync: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PacketId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketFee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PacketFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPayPacketFeeAsyncResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPayPacketFeeAsyncResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPayPacketFeeAsyncResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
